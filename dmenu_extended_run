#! /usr/bin/env python
# -*- coding: utf8 -*-
import dmenu_extended
import os
import sys

def handle_command(d, out):
    if out[0] == ';' or out[-1] == ';':
        for command in out.split('&&'):
            if command.find('/') != -1:
                print("-cd " + command.replace(';',''))
                d.open_terminal("-cd " + command.replace(';',''),direct=True)
            else:
                d.open_terminal(command.replace(';',''))

    elif out[:7] == 'http://' or out[:8] == 'https://':
        d.open_url(out)

    elif out.find('/') != -1:
        if out.find(' ') != -1:
            parts = out.split(' ')
            if parts[0] in d.scan_binaries():
                d.execute(out)
            else:
                if os.path.isdir(out):
                    d.open_directory(out)
                else:
                    d.open_file(out)
        else:
            if os.path.isdir(out):
                d.open_directory(out)
            else:
                d.open_file(out)
    else:
        d.execute(out)

def run(argv):

    d = dmenu_extended.dmenu(argv)
    cache = d.cache_load()
    out = d.menu(cache,'Open:').strip()

    if len(out) > 0:
        # Check if the action relates to a plugin
        plugins = dmenu_extended.load_plugins()
        plugin_hook = False
        for plugin in plugins:
            if hasattr(plugin['plugin'], 'is_submenu') and plugin['plugin'].is_submenu == True:
                pluginTitle = d.submenu_indicator + plugin['plugin'].title
            else:
                pluginTitle = plugin['plugin'].title

            if out[:len(pluginTitle)] == pluginTitle:
                plugin_hook = plugin["plugin"]

        # Check for plugin call
        if plugin_hook != False:
            plugin_hook.run(out[len(pluginTitle):])
        else:

            # Check for store modifications
            if out[0] == '+':
                out = out[1:]
                store = d.load_json(d.path_preferences)
                operation_is_add = True
                if out not in store['include_items']:
                    store['include_items'].append(out)
                else:
                    store['include_items'].remove(out)
                    operation_is_add = False
                
                d.save_json(d.path_preferences, store)
                
                cache_scanned = d.cache_open(d.path_base + '/cache_scanned.txt')[:-1]

                if cache_scanned == False:
                    d.message_open("Performing action with: " + out)
                    d.cache_regenerate()
                    d.message_close()
                    sys.exit()
                else:
                    cache_scanned = cache_scanned.split("\n")

                if operation_is_add:
                    print("Adding item to store: " + out)
                    d.message_open("Adding item to store: " + out)
                    cache_scanned = [out] + cache_scanned
                    cache_scanned.sort(key=len)
                else:
                    print("Removing item from store: " + out)
                    d.message_open("Removing item from store: " + out)
                    cache_scanned.remove(out)

                d.cache_save(cache_scanned, d.path_base + '/cache_scanned.txt')
                
                d.message_close()
                if operation_is_add:
                    d.menu("Item added to cache")
                else:
                    d.menu("Item removed from cache")
                sys.exit()

            # Check for open-with/filter results modifier
            if out.find(':') != -1:
                tmp = out.split(':')
                if len(tmp) != 2:
                    print('Input command not understood')
                    sys.exit()
                else:
                    cmds = map(lambda x: x.strip(), tmp)

                if cmds[0] == '':
                    items = filter(lambda x: x.find(cmds[1]) != -1, cache.split('\n'))
                    item = d.menu(items)
                    handle_command(d, item)
                elif cmds[0] in d.scan_binaries():
                    print('Item[0] (' + cmds[0] + ') found in binaries')
                    # Get paths from cache
                    items = filter(lambda x: x.find('/') != -1, cache.split('\n'))
                    # If extension passed, filter by this
                    if cmds[1] != '':
                        items = filter(lambda x: x.find(cmds[1]) != -1, items)
                    filename = d.menu(items)
                    filename = os.path.expanduser(filename)
                    command = cmds[0] + " '" + filename + "'"
                    d.execute(command)
                elif cmds[0].find('/') != -1:
                    # Path came first, assume user wants of open it with a bin
                    if cmds[1] != '':
                        command = cmds[1] + " '" + os.path.expanduser(cmds[0]) + "'"
                    else:
                        binary = d.menu(d.scan_binaries())
                        command = binary + " '" + os.path.expanduser(cmds[0]) + "'"
                    d.execute(command)
                else:
                    d.menu(["Cant find " + cmds[0] + ", is it installed?"])
                    print('Input command not understood')

                sys.exit()

            if out == "rebuild cache":
                result = d.cache_regenerate()
                if result == 0:
                    d.menu(['Cache could not be saved'])
                elif result == 2:
                    d.menu(['Cache rebuilt','Performance issues were detected - some paths contained invalid characters'])
                else:
                    d.menu(['Success!'])

            else:
                handle_command(d, out)


if __name__ == '__main__':
    run(sys.argv[1:])
